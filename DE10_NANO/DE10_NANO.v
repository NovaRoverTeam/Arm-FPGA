
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module DE10_NANO(
	//////////// ARDUINO //////////
	inout 		    [15:0]		ARDUINO_IO,
	inout 		          		ARDUINO_RESET_N,

	//////////// CLOCK //////////
	input 		          		FPGA_CLK1_50,
	input 		          		FPGA_CLK2_50,
	input 		          		FPGA_CLK3_50,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// LED //////////
	output		     [7:0]		LED,

	//////////// SW //////////
	input 		     [3:0]		SW,

	//////////// GPIO_0, GPIO connect to GPIO Default //////////
	inout 		    [35:0]		GPIO_0,

	//////////// GPIO_1, GPIO connect to GPIO Default //////////
	inout 		    [35:0]		GPIO_1
);

//=======================================================
	//  REG/WIRE declarations
	//=======================================================
	/*
	// Base Signals
	wire wBase_Enc = GPIO_0[0];
	wire wBase_Dir = GPIO_0[6];
	wire wBase_Pwm = GPIO_0[4];
	wire wBase_Brake = GPIO_0[2];
	wire wBase_Rst = GPIO_0[8];
		
	// Actuator Lower
	wire wActuator_Lower_Dir = GPIO_0[17];
	wire wActuator_Lower_PWM = GPIO_0[15];
	wire wActuator_Lower_Enc = GPIO_0[1];
	
	// Actuator Lower
	wire wActuator_Upper_Dir = GPIO_0[13];
	wire wActuator_Upper_Pwm = GPIO_0[11];
	wire wActuator_Upper_Enc = GPIO_0[10];	
	
	// Wrist Horizontal
	wire wWrist_Horizontal_Dir = GPIO_0[23];
	wire wWrist_Horizontal_Pwm = GPIO_0[25];
	wire wWrist_Horizontal_EncA = GPIO_0[20];
	wire wWrist_Horizontal_EncB = GPIO_0[22];
	wire wWrist_Horizontal_Rst = GPIO_0[18];
	
	// Wrist Vertical
	wire wWrist_Vertical_Dir = GPIO_0[19];
	wire wWrist_Vertical_Pwm = GPIO_0[21];
	wire wWrist_Vertical_EncA = GPIO_0[14];
	wire wWrist_Vertical_EncB = GPIO_0[16];
	wire wWrist_Vertical_Rst = GPIO_0[12];
	
	// Wrist Rotation
	wire wWrist_Rotation_Dir = GPIO_0[29];
	wire wWrist_Rotation_Pwm = GPIO_0[27];
	wire wWrist_Rotation_EncA = GPIO_0[31];
	wire wWrist_Rotation_EncB = GPIO_0[33];
	wire wWrist_Rotation_Rst = GPIO_0[35];
	
	// Effector Angle
	wire wEffector_Angle_Dir = GPIO_0[3];
	wire wEffector_Angle_Pwm = GPIO_0[5];
	wire wEffector_Angle_EncA = GPIO_0[32];
	wire wEffector_Angle_EncB = GPIO_0[28];
	wire wEffector_Angle_Rst = GPIO_0[34];
	
	// Effector Position
	wire wEffector_Position_Dir = GPIO_0[7];
	wire wEffector_Position_Pwm = GPIO_0[9];
	wire wEffector_Position_EncA = GPIO_0[26];
	wire wEffector_Position_EncB = GPIO_0[24];
	wire wEffector_Position_Rst = GPIO_0[30];
	
	*/
	//assign GPIO_1[35:0] = GPIO_0[35:0];
	
	//assign LED = {!wEffector_Position_Rst,!wEffector_Angle_Rst,!wWrist_Rotation_Rst,!wWrist_Vertical_Rst,!wWrist_Horizontal_Rst,0,0,!wBase_Rst};
	
	//=======================================================
	//  Structural coding
	//=======================================================
	//assign GPIO_0[35:0] = {FPGA_CLK1_50,FPGA_CLK1_50,FPGA_CLK1_50,FPGA_CLK1_50,FPGA_CLK1_50,FPGA_CLK1_50,FPGA_CLK1_50,FPGA_CLK1_50,FPGA_CLK1_50,FPGA_CLK1_50,FPGA_CLK1_50,FPGA_CLK1_50,FPGA_CLK1_50,FPGA_CLK1_50,FPGA_CLK1_50,FPGA_CLK1_50,FPGA_CLK1_50,FPGA_CLK1_50,FPGA_CLK1_50,FPGA_CLK1_50,FPGA_CLK1_50,FPGA_CLK1_50,FPGA_CLK1_50,FPGA_CLK1_50,FPGA_CLK1_50,FPGA_CLK1_50,FPGA_CLK1_50,FPGA_CLK1_50,FPGA_CLK1_50,FPGA_CLK1_50,FPGA_CLK1_50,FPGA_CLK1_50,FPGA_CLK1_50,FPGA_CLK1_50,FPGA_CLK1_50,FPGA_CLK1_50};
	
	reg key0, key1;
	reg [10:0] count1000;
	reg CLK50k;
	
	always @(posedge FPGA_CLK1_50) begin
		key0 <= KEY[0];
		key1 <= KEY[1];
	end
	
	always @(posedge FPGA_CLK1_50) begin
		
		if (count1000 >= 250)
			begin
				count1000 <= 0;
				CLK50k <= !CLK50k;
			end
		else
			begin
				count1000 <= count1000+1;
			end
	end
	
	assign GPIO_1[0] = CLK50k;

	assign GPIO_1[34] = GPIO_0[0];
	assign GPIO_1[35] = GPIO_0[8];
	
	linear_actuator lower (	.iClk(FPGA_CLK1_50),
							.iEnc(GPIO_0[35]),
							.iRst(!key1||!key0),
							.iSSEL(ARDUINO_IO[9]),
							.iMOSI(ARDUINO_IO[11]),
							.iSCK(ARDUINO_IO[13]),
							.oMISO(ARDUINO_IO[12]),
							.oDir(GPIO_0[19]),
							.oPwm(GPIO_0[5]));
						
	linear_actuator upper (	.iClk(FPGA_CLK1_50),
							.iEnc(GPIO_0[24]),
							.iRst(!key1||!key0),
							.iSSEL(ARDUINO_IO[8]),
							.iMOSI(ARDUINO_IO[11]),
							.iSCK(ARDUINO_IO[13]),
							.oMISO(ARDUINO_IO[12]),
							.oDir(GPIO_0[23]),
							.oPwm(GPIO_0[25]));		
	
	wormgear_motor wrist_horizontal (	.iClk(FPGA_CLK1_50),
							.iEncA(GPIO_0[14]),
							.iEncB(GPIO_0[12]),
							.iRst(!GPIO_0[16]||!key0),
							.iSSEL(ARDUINO_IO[7]),
							.iMOSI(ARDUINO_IO[11]),
							.iSCK(ARDUINO_IO[13]),
							.oMISO(ARDUINO_IO[12]),
							.oDir(GPIO_0[13]),
							.oPwm(GPIO_0[11]));

	wormgear_motor wrist_vertical (	.iClk(FPGA_CLK1_50),
							.iEncA(!GPIO_0[18]),
							.iEncB(!GPIO_0[20]),
							.iRst(!GPIO_0[22]||!key0),
							.iSSEL(ARDUINO_IO[6]),
							.iMOSI(ARDUINO_IO[11]),
							.iSCK(ARDUINO_IO[13]),
							.oMISO(ARDUINO_IO[12]),
							.oDir(GPIO_0[17]),
							.oPwm(GPIO_0[15]));
							
	
	direct_drive wrist_rotation (	.iClk(FPGA_CLK1_50),
							.iSSEL(ARDUINO_IO[5]),
							.iMOSI(ARDUINO_IO[11]),
							.iSCK(ARDUINO_IO[13]),
							.oMISO(ARDUINO_IO[12]),
							.oDir(GPIO_0[7]),
							.oPwm(GPIO_0[9])
							);
						
							
	base_motor b1 (	.iClk(FPGA_CLK1_50),
							.iEnc(GPIO_0[34]),
							.iRst(!GPIO_0[26]||!key0),
							.iSSEL(ARDUINO_IO[10]),
							.iMOSI(ARDUINO_IO[11]),
							.iSCK(ARDUINO_IO[13]),
							.oMISO(ARDUINO_IO[12]),
							.oDir(GPIO_0[28]),
							.oPwm(GPIO_0[30]),
							.oBrake(GPIO_0[32]));
							
							
							
	wormgear_motor end_angle (	.iClk(FPGA_CLK1_50),
							.iEncA(GPIO_0[2]),
							.iEncB(GPIO_0[6]),
							.iRst(!GPIO_0[4]||!key0),
							.iSSEL(ARDUINO_IO[4]),
							.iMOSI(ARDUINO_IO[11]),
							.iSCK(ARDUINO_IO[13]),
							.oMISO(ARDUINO_IO[12]),
							.oDir(GPIO_0[33]),
							.oPwm(GPIO_0[31]));
							
	wormgear_motor end_position (	.iClk(FPGA_CLK1_50),
							.iEncA(GPIO_0[0]),
							.iEncB(GPIO_0[8]),
							.iRst(!GPIO_0[10]||!key0),
							.iSSEL(ARDUINO_IO[3]),
							.iMOSI(ARDUINO_IO[11]),
							.iSCK(ARDUINO_IO[13]),
							.oMISO(ARDUINO_IO[12]),
							.oDir(GPIO_0[29]),
							.oPwm(GPIO_0[27]));
							

							

endmodule

module base_motor(iClk, iEnc, iRst, iSSEL, iMOSI, iSCK, oMISO, oDir, oPwm, oBrake, oCount);
	input iClk, iEnc, iRst, iSSEL, iMOSI, iSCK;
	output oDir, oPwm, oBrake, oMISO;
	output [11:0] oCount;
	
	//=======================================================
	//  REG/WIRE declarations
	//=======================================================

	wire base_filtered;
	wire base_count;
	wire [11:0] base_position;

	wire [15:0] base_velocity;
	wire base_direction;
	wire [15:0] base_duty;

		
	assign oCount = base_position;
	
	assign oDir = !base_direction;
	assign oBrake = !(base_velocity==0);

	//=======================================================
	//  Structural coding
	//=======================================================

	digital_filter base_enc (	.iClk(iClk),
											.iIn(iEnc),
											.oOut(base_filtered));
											
	encoder_decoder	base_dec(.iClk(iClk),
											.iSignal(base_filtered), 
											.oCount(base_count));										

	position_counter base_pos (.iCount(base_count),
											.iDirection(base_direction),
											.iRst(iRst),
											.oPosition(base_position));
											defparam base_pos .width=15;
											defparam base_pos .MAX=6000;

	SPI_slave base_com (			.iClk(iClk), 
											.iSCK(iSCK), 
											.iMOSI(iMOSI), 
											.oMISO(oMISO), 
											.iSSEL(iSSEL), 
											.oRx(base_velocity),
											.iTx({5'd0,base_position}));
											
	speed_decoder base_spd (	.iVelocity(base_velocity),
											.oDirection(base_direction),
											.oDuty(base_duty));
								
	PWM base_pwm (	.iClk(iClk), 
							.iDuty(4095-base_duty[11:0]),
							.oPwm(oPwm));
							defparam base_pwm.frequency = 10000;
							defparam base_pwm.width = 12;
endmodule 

module direct_drive (iClk,iSSEL, iMOSI, iSCK, oMISO, oDir, oPwm);
	input iClk, iSSEL, iMOSI, iSCK;
	output oDir, oPwm, oMISO;
	
	wire [15:0] motor_velocity;
	wire [15:0] motor_duty;
	
	SPI_slave motor_com (			.iClk(iClk), 
											.iSCK(iSCK), 
											.iMOSI(iMOSI), 
											.oMISO(oMISO), 
											.iSSEL(iSSEL), 
											.oRx(motor_velocity),
											.iTx({16'd12345}));
											
	speed_decoder motor_spd (	.iVelocity(motor_velocity),
											.oDirection(oDir),
											.oDuty(motor_duty));
								
	PWM motor_pwm (	.iClk(iClk), 
							.iDuty(motor_duty[11:0]),
							.oPwm(oPwm));
							defparam motor_pwm.frequency = 10000;
							defparam motor_pwm.width = 12;

endmodule 


module wormgear_motor (iClk, iEncA, iEncB, iRst, iSSEL, iMOSI, iSCK, oMISO, oDir, oPwm, oCount);
	input iClk, iEncA, iEncB, iRst, iSSEL, iMOSI, iSCK;
	output oDir, oPwm, oMISO;
	output [14:0] oCount;
	
	//=======================================================
	//  REG/WIRE declarations
	//=======================================================

	wire wormgear_filteredA;
	wire wormgear_filteredB;
	wire wormgear_count;
	wire [14:0] wormgear_position;

	wire [15:0] wormgear_velocity;
	wire wormgear_direction;
	wire [15:0] wormgear_duty;

		
	assign oCount = wormgear_position;
	

	//=======================================================
	//  Structural coding
	//=======================================================

	digital_filter wormgear_encA (	.iClk(iClk),
											.iIn(iEncA),
											.oOut(wormgear_filteredA));
											
	digital_filter wormgear_encB (	.iClk(iClk),
											.iIn(iEncB),
											.oOut(wormgear_filteredB));
											
	quaderature_decoder	wormgear_dec(.iClk(iClk),
											.iSignalA(wormgear_filteredA), 
											.iSignalB(wormgear_filteredB),
											.oDirection(wormgear_direction),
											.oCount(wormgear_count));										

	position_counter wormgear_pos (.iCount(wormgear_count),
											.iDirection(!wormgear_direction),
											.iRst(iRst),
											.oPosition(wormgear_position));
											defparam wormgear_pos .width=15;
											defparam wormgear_pos .MAX=24000;


	SPI_slave wormgear_com (			.iClk(iClk), 
											.iSCK(iSCK), 
											.iMOSI(iMOSI), 
											.oMISO(oMISO), 
											.iSSEL(iSSEL), 
											.oRx(wormgear_velocity),
											.iTx({5'd0,wormgear_position}));
											
	speed_decoder wormgear_spd (	.iVelocity(wormgear_velocity),
											.iRst(iRst),
											.oDirection(oDir),
											.oDuty(wormgear_duty));
								
	PWM wormgear_pwm (	.iClk(iClk), 
							.iDuty(wormgear_duty[11:0]),
							.oPwm(oPwm));
							defparam wormgear_pwm.frequency = 10000;
							defparam wormgear_pwm.width = 12;


endmodule 

module linear_actuator (iClk, iEnc, iRst, iSSEL, iMOSI, iSCK, oMISO, oDir, oPwm, oCount);
	input iClk, iEnc, iRst, iSSEL, iMOSI, iSCK;
	output oDir, oPwm, oMISO;
	output [11:0] oCount;
	
	
	//=======================================================
	//  REG/WIRE declarations
	//=======================================================

	wire lin_act_filtered;
	wire lin_act_count;
	wire [11:0] lin_act_position;

	wire [15:0] lin_act_velocity;
	wire lin_act_direction;
	wire [15:0] lin_act_duty;

		
	assign oCount = lin_act_position;
	assign oDir = !lin_act_direction;

	//=======================================================
	//  Structural coding
	//=======================================================

	digital_filter lin_act_enc (	.iClk(iClk),
											.iIn(iEnc),
											.oOut(lin_act_filtered));
											
	encoder_decoder	lin_act_dec(.iClk(iClk),
											.iSignal(lin_act_filtered), 
											.oCount(lin_act_count));										

	position_counter lin_act_pos (.iCount(lin_act_count),
											.iDirection(!lin_act_direction),
											.iRst(iRst),
											.oPosition(lin_act_position));
											defparam lin_act_pos .width=11;
											defparam lin_act_pos .MAX=1820;


	SPI_slave lin_act_com (			.iClk(iClk), 
											.iSCK(iSCK), 
											.iMOSI(iMOSI), 
											.oMISO(oMISO), 
											.iSSEL(iSSEL), 
											.oRx(lin_act_velocity),
											.iTx({5'd0,lin_act_position}));
											
	speed_decoder lin_act_spd (	.iVelocity(lin_act_velocity),
											.oDirection(lin_act_direction),
											.oDuty(lin_act_duty));
								
	PWM lin_act_pwm (	.iClk(iClk), 
							.iDuty(lin_act_duty[11:0]),
							.oPwm(oPwm));
							defparam lin_act_pwm.frequency = 10000;
							defparam lin_act_pwm.width = 12;


endmodule 

module speed_decoder(iVelocity, iRst, oDirection, oDuty);
	input [15:0] iVelocity;
	input iRst;
	output reg oDirection;
	parameter width = 16;
	output reg [width-1:0] oDuty;
	
	always @(iVelocity)
		begin
			if (iVelocity[15]==1)
				begin
					oDirection = 1;
					oDuty = (~(iVelocity-1'b1));
				end
			else 
				begin
					oDirection = 0;
					
					if (iRst == 1 && iVelocity == 4095)
						begin
							oDuty = 0;
						end
					else
						begin
							oDuty = iVelocity;
						end
				end
		end
endmodule

module SPI_slave(iClk, iTx, iSCK, iMOSI, oMISO, iSSEL, oRx);
	input iClk;

	input iSCK, iSSEL, iMOSI;
	input [15:0] iTx;
	output oMISO;

	output reg [15:0] oRx;

	// sync iSCK to the FPGA clock using a 3-bits shift register
	reg [2:0] iSCKr;  always @(posedge iClk) iSCKr <= {iSCKr[1:0], iSCK};
	wire iSCK_risingedge = (iSCKr[2:1]==2'b01);  // now we can detect iSCK rising edges
	wire iSCK_fallingedge = (iSCKr[2:1]==2'b10);  // and falling edges

	// same thing for iSSEL
	reg [2:0] iSSELr;  always @(posedge iClk) iSSELr <= {iSSELr[1:0], iSSEL};
	wire iSSEL_active = ~iSSELr[1];  // iSSEL is active low
	wire iSSEL_startmessage = (iSSELr[2:1]==2'b10);  // message starts at falling edge
	wire iSSEL_endmessage = (iSSELr[2:1]==2'b01);  // message stops at rising edge

	// and for iMOSI
	reg [1:0] iMOSIr;  always @(posedge iClk) iMOSIr <= {iMOSIr[0], iMOSI};
	wire iMOSI_data = iMOSIr[1];

	// we handle SPI in 8-bits format, so we need a 3 bits counter to count the bits as they come in
	reg [3:0] bitcnt;

	reg byte_received;  // high when a byte has been received
	reg [15:0] byte_data_received;

	always @(posedge iClk)
	begin
	  if(~iSSEL_active)
		 bitcnt <= 4'b0000;
	  else
	  if(iSCK_risingedge)
	  begin
		 bitcnt <= bitcnt + 4'b0001;

		 // implement a shift-left register (since we receive the data MSB first)
		 byte_data_received <= {byte_data_received[15:0], iMOSI_data};
	  end
	end

	always @(posedge iClk) byte_received <= iSSEL_active && iSCK_risingedge && (bitcnt==4'b1111);

	// we use the LSB of the data received to control an oRx
	always @(posedge iClk) if(byte_received) oRx <= byte_data_received[15:0];

	reg [15:0] byte_data_sent;

	reg [15:0] cnt;
	always @(posedge iClk) if(iSSEL_startmessage) cnt<=cnt+16'h1;  // count the messages

	always @(posedge iClk)
	if(iSSEL_active)
	begin
	  if(iSSEL_startmessage)
		 byte_data_sent <= iTx;  // first byte sent in a message is the message count
	  else
	  if(iSCK_fallingedge)
	  begin
		 if(bitcnt==4'b0000)
			byte_data_sent <= 16'h0000;  // after that, we send 0s
		 else
			byte_data_sent <= {byte_data_sent[15:0], 1'b0};
	  end
	end

	assign oMISO = (iSSEL_active) ? byte_data_sent[15] : 1'bz;  // send MSB first
	
	
	// we assume that there is only one slave on the SPI bus
	// so we don't bother with a tri-state buffer for oMISO
	// otherwise we would need to tri-state oMISO when iSSEL is inactive

endmodule





module PWM(iClk, iDuty, oPwm);
	input iClk;
	parameter width = 12;
	input [width-1:0] iDuty;
	output reg oPwm = 0;
	
	parameter frequency = 50;
	parameter n = 2**width;
	parameter maxclk = 50000000/frequency;//(frequency*n);
	
	reg [26:0]counter1 = 0;
	
	always @ (posedge iClk)
		begin
			if (counter1 >= maxclk)
				begin
					counter1 <= 0;
				end
			else
				begin
					counter1 <= counter1 + 1;
				end
			
			if (counter1 >= iDuty*maxclk/n)
				begin
					oPwm <= 0;
				end
			else
				begin
					oPwm <= 1;
				end
		end
endmodule

module position_counter(iClk, iDirection, iCount, iRst, oPosition, oSpeed); // Counts position of a joint
	input iClk, iDirection, iCount, iRst;
	parameter width = 13;
	output reg [width-1:0]oPosition = 0;
	output reg [width-1:0]oSpeed;
	
	parameter MAX = 5000;
	//1820 for linear actuator
	
	always @ (posedge iCount or posedge iRst)
		begin
			if (iRst)
				begin
					oPosition <= 0;
				end
			else if ((iDirection == 1) && (oPosition < MAX))
				begin
					oPosition <= oPosition + 1;
				end	
			else if ((oPosition > 0) && (iDirection == 0))
				begin
					oPosition <= oPosition - 1;
				end
		end

endmodule

module quaderature_decoder(iClk, iSignalA, iSignalB, oDirection, oCount);
	input iClk, iSignalA, iSignalB;
	output reg oDirection, oCount;
	
	reg last_SignalA;
	reg last_SignalB;
	
	always @ (posedge iClk)
		begin
			case ({last_SignalA, last_SignalB, iSignalA, iSignalB})
				4'b0001:
					begin
						oDirection <= 1;
						oCount <= 1;
					end
				4'b0010:
					begin
						oDirection <= 0;
						oCount <= 1;
					end
				4'b0100:
					begin
						oDirection <= 0;
						oCount <= 1;
					end
				4'b0111:
					begin
						oDirection <= 1;
						oCount <= 1;
					end
				4'b1000:
					begin
						oDirection <= 1;
						oCount <= 1;
					end
				4'b1011:
					begin
						oDirection <= 0;
						oCount <= 1;
					end
				4'b1110:
					begin
						oDirection <= 1;
						oCount <= 1;
					end
				4'b1101:
					begin
						oDirection = 0;
						oCount <= 1;
					end
				default: 
					begin
						oCount <= 0;
					end
			
			endcase
			last_SignalA <= iSignalA;
			last_SignalB <= iSignalB;
		end
endmodule

module encoder_decoder(iClk, iSignal, oCount); // Single encoder line decoder. Returns a single clock pulse as output on an encoder signal change.
	input iClk, iSignal;
	output reg oCount;
	
	reg last_Signal;
	
	always @ (posedge iClk)
		begin
			if (last_Signal != iSignal)
				begin
					oCount <= 1;
				end
			else
				begin
					oCount <= 0;
				end
			last_Signal <= iSignal;
		end
		
	
endmodule

module digital_filter(iClk, iIn, oOut);		// Filters signal change bounce by making sure the signal hasn't changed for a large number of clock cycles before output changes.
	input iClk, iIn;
	output reg oOut;
	parameter samples = 4095;
	// 511 seemed to fix wrist motor at constant 1V
	
	reg [11:0] count = 0;
	reg last_In;
	
	always @ (posedge iClk)
		begin
			if (last_In != iIn)
				begin
					count = 0;
				end
			else if (last_In == iIn && count < samples)
				begin
					count = count + 1;
				end
			if (count == samples)
				begin
					oOut = iIn;
					count = 0;
				end
			last_In = iIn;
		end
endmodule



